# We have forgotten the point of Agile

This is the Mind Map of the "forgotten the point" article.

![Article Mind Map](./images/Agile_ForgettingThePoint_MindMap.png)

## TLDR of the whole series

1. **Have we forgotten the point of "Agile"?** Yes! First and foremost, it was a defensive way of delivering work in a frictionless, unconstrained un-reality of infinite possibilities. Once we remember this, it all makes a lot more sense.
2. **"[Agile" Anti-Patterns](./Agile_AntiPatterns.md):** when software engineers, product people and designers all work at loggerheads to each other, it all goes belly up. And even more so when the ways we strategise *aren't* agile.
3. **[Valuable agility](./Agile_Value.md):** conversely, when software, product and design collaborate beautifully, it's possible to navigate the "Digital Realm*" not only safely, but in ways that put you way ahead of the competition.

\* It's like the Quantum Realm from Ant-Man but with *a lot more meetings*.

## Whose bandwagon am I shamelessly jumping onto?

Why - Dave Thomas's of course... He famously\* declared "[Agile is dead](https://youtu.be/a-BOSpxYJ9M?si=m5g_B7sa9_wK06cp)" in 2015, and that opened the door for a great many others to jump through. A large cohort of these folks seem to be computer programmers who don't like meetings (more in the next one), but it also struck a chord with Dave's fellow dignitaries of the agilista community.

Dave's most elegant point concerns the difference between:

* **"Small-a-agility":** where agile remains an adjective, i.e. something describing behaviour.
* **"Capital-A-Agile":** which is a noun, i.e. something you can package up into a certified training course and sell to people.

I like this concept so I'm going to steal it for these articles. I'm also going to refer to the [update he's started giving](https://youtu.be/bEMg9XXIcew?si=WMmJucZFqZma3xt0) to the original talk, too.

\* Well, for a computer programmer - Dave's not Taylor Swift, exactly. Indeed he's probably not even Sue Pollard. But his talk has had 1.4 million views.

## Does *anyone* remember the point?

The OG agilistas Allen Holub and Dave Farley\* [nearly do](https://youtu.be/hxXmTnb3mFU?t=665) - Dave talks about small-a-agility "opening up infinite possibilities" as opposed to being "fundamentally constrained" by big-design-up-front. But it's not the *agility* that opens-up infinite possibilities, and "waterfall approaches" can't and don't ever *actually* constrain you.

Working in the Digital Realm *causes* these endless, frictionless possibilities, which no amount of up-front-design can cope with. Designs and concepts in the Digital Realm refuse to remain fixed. Even the most detailed of design drawings will get diddled with as soon as you try and implement it, and even assuming you get close, it won't be long before you've tweaked the implementation out of step with the design; purely *because you can*, and you'll interpret it differently to the intention.

Small-a-agility was originally conceived as a *defence mechanism to cope with all this*. This is what we have lost sight of.

\* I'll probably refer to Dave Farley a lot in these articles. Just in case you don't know, Dave co-wrote [Continuous Delivery](https://martinfowler.com/books/continuousDelivery.html); a strong candidate for being the Bible of small-a-agile software engineering.

### Agile beginnings

James Shore and Shane Warden include a great potted-history of both Agile and agility in the second edition of [The Art of Agile Development](https://www.jamesshore.com/v2/books/aoad2). They describe a "crisis of software development" in the 1990s, caused by attempts to control every aspect of software production with highly regulated and governed processes. This is the world of the Unified Modelling Language, the Rational Software Development process and "heavyweight", "waterfall" project management methods such as Prince2. It's a world of big-design-up-front and loads of gates that projects have to get through, or around.

Less than one-in-six succeeded, according to the spectacularly-titled "[CHAOS Report](https://www.csus.edu/indiv/v/velianitis/161/chaosreport.pdf)" of 1995. Interestingly, that report begins by contrasting software engineering with bridge-building, though without actually getting to the bottom of it. They cite "we have 3000 years of bridge-building experience" as the main difference, but I'd also suggest "being constrained by the laws of physics and only four dimensions within which to work" as being extra advantages that bridge-builders have over software engineers. Provided, of course, one measures success as per the report: "...having all the features as initially specified", which has a bridge-buildy ring to it, too.

It's much easier to specify a bridge, in other words, and much harder to start building a serious one without a design, budget, team and plan in place. Shore and Warden suggest that it *might be* possible to apply all that up-front planning to software engineering, too, "... if you keep them slim and operate in a well-understood domain". This goes against my personal experience.

### Univeral Machines and infinite spaces

I've been extremely lucky to be coached by two different software engineers\* who really got small-a-agility. One of them told me a story about helping his dad, a Quantity Surveyor in the Real World, select some software to use. After he'd helped pick the best system for his dad to buy, he told him how lucky he was to know, up front, how big a space there would be to build in, and to have the laws of physics constrain everything.

We don't have these luxuries in the Digital Realm - if your client decides that they would like a submarine dock in the basement of the hospital you've spent the last three years building them, and a space-port on the roof, and that they'd like you to put the ceilings in before you've built the walls, then there's no practical reason why you can't. We work with "Universal Turing Machines" in a slippery, frictionless world of (very nearly) pure information and imagination: there are zero physical constraints.

"You're driving me nuts" doesn't cut it as a defence against this, either - they'll just find someone else to burn out instead of you, at least until their money runs out. "You're the boss" and "I was only following orders" can help a certain caste of programmer on the sanity front, but will only ever result in something good by the flukiest of accidents.

\* More Dave Farley here, on [the difference between Programmers, Developers and Engineers](https://www.youtube.com/watch?v=fcjBfSiyI0k&t=2s).

### Lack of friction

So the infinity and lack of friction results in constant uncertainty about what we do. It also means that everything we *do* achieve is much more vulnerable to disruption than Real World endeavours. The Digital Realm has an extremely low barrier to entry - case in point: how two broke students [completely turned the world of travel accommodation upside down](https://knowledge.wharton.upenn.edu/podcast/knowledge-at-wharton-podcast/the-inside-story-behind-the-unlikely-rise-of-airbnb/).

If our laurels are in the Digital Realm then we can never rest on them. Even if we are hugely successful, we have to be able to re-invent everything over and over again. Take Microsoft Office as an example of that - it's been rebuilt from the ground up four or five times over the years - the only constant is the brand. The same old boss of mine used to describe this as "re-building the engine of a sports car while it's doing 170 mph in the fast lane".

This is *nearly* impossible - with small-a-agility tipping the balance from "completely" to "nearly".

### "It lets you change direction" misses the point

It's not capital-A-Agile that's "letting you change direction". Working in the Digital Realm *means you are going to change direction* whether you like it or not. There's literally nothing stopping you. I've been in situations during my engineering career where the thing I thought I was working on would change three or four times in a day. I would go into work clear in my head about what I would be working on, and my precious sense of certainty would be nothing but a glorious memory by 9:30am.

Small-a-agility is the only thing that gives us a cat-in-hell's chance of managing our adventures in the Digital Realm. So to paraphrase Churchill: "it's the worse form of planning and management, apart from all the others".

### Manufactured constraints

The defence against frictionless uncertainty is to *manufacture constraints* to work within. The ones that can be made to work are *time* and *money*.

Uncertainty is a constant, so if we work in teeny-tiny increments of time, and check where we are at the end of every increment, we're at least only ever uncertain about a few things at a time, for a short while. Dave Thomas nails this in the [follow-up to his original talk](https://youtu.be/bEMg9XXIcew?si=WMmJucZFqZma3xt0). Money (or should I say *value*?) gives us a direction to travel in. Even tiny-little baby steps waste time and effort if you take them in the wrong direction. Dave Thomas is a bit sketchier on this, referring in passing to "your goal" throughout his follow-up, though he does circle round to it during the questions at the end.

**Massive spoiler alert:** the money thing is **much harder to get right**, because it requires business people that understand design and engineering, and engineers and designers who get business. Gulp!

## Why information and knowledge work is so different

### Vagueness and ambiguity

So how about Shore and Warden's "well understood domains"? Well, maybe I've just been unlucky, but in my experience the idea that we can define what the various "domains" that relate to the problems we're solving has never really stood up. And not so much "define them accurately", even - "well enough to make any progress" would do. Ditto other domain-related ideas such as the "bounded-contexts" that surround them, and the "ubiquitous languages" that everyone within them uses consistently, apparently.

You may recognise these concepts as being from Domain Driven Design - which comes with its own [big, blue Bible](https://learning.oreilly.com/library/view/domain-driven-design-tackling/0321125215/). I'm not especially *anti* DDD, but I'd class it as a *nice theory*, along with various other Thoughtworksy concepts that depend upon it such as [Data Mesh](https://learning.oreilly.com/library/view/data-mesh/9781492092384/). It's never survived any attempts at engaging business people anywhere I've ever worked, anyway - I suspect it takes particularly talented, experienced and presumably expensive consultants to get it across, and even then any clarity achieved is likely to be fleeting.

Instead, attempts to get to the bottom of problems usually approach via pre-defined "solutions", and so we attempt to describe them in those terms: "we need this feature", "the software should do this" etc. If you're into Lean, then you're supposed to ask "why" five times when this happens, but as this is what *extremely annoying four-year-old children do*, I don't recommend it.

Asking "why" over and over is a symptom of a dark truth lurking beneath software production: you'll *never* get a perfect fit between a digital system and reality. The quest for perfection can get brain-snappingly, toe-curlingly abstract pretty damn quick, and logic traps can start to snap at everyone's sanity. You know this is happening when the business-people / subject matter experts in the room gradually fall silent, and the programmers start trying to one-up each other with technical terms.

When I was working in the Finance Industry (I use the term pretty loosely), I once saw the 6'3" general manager of a debt collection company (a guy with muscles on his muscles) reduced half to tears by a five-foot-four, stick-thin, seven-stone-soaking-wet computer programmer. "The poor, poor guy", I thought, as Mr. Muscles sobbed: "Why does all this have to be so complicated?" into his hand.

Turns out we were just asking the wrong questions, of course, but more of that later. The core point remains that The Digital Realm never fits smoothly with reality. See [Douglas Hofstadter](https://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach) and [Roger Penrose](https://en.wikipedia.org/wiki/The_Emperor%27s_New_Mind) for further details.

### Your spec will *never* be fixed

If I had a shiny pound coin for every time I've heard someone say: "where's the specification?", "have you captured all the requirements" or "can you show me the picture of what want?" then, well I'd at least have a free holiday.

That's not to say *pictures* in particular aren't useful, they really can be (until they get too busy - like [this one](https://framework.scaledagile.com/#largesolution)), but even the clearest picture in the world...:

* Won't stay clear and current for very long - sometimes less than an hour or two after clarity was achieved.
* Won't transfer exactly to a code implementation - any two programmers *will* interpret it in a **minimum** of two different ways.

Clarity is fleeting and uncertainty is rife. The best pictures can give a sense of direction, but the only safe things to do are: 

* Not travel too far in *any* direction without checking you're going the right way.
* Make it very easy to go back and not get upset when you have to.

Loads of effort on designs, plans, pictures or story maps that go into explicit detail about stuff you definitely might do ~~in six months~~ ~~three months~~ ~~three weeks~~ next week disinclines everyone from backing up and trying again, so instead we all plough on getting further away from anything good.

### Glimpses of good answers are the best you can hope for

You just have to talk to the people with the problem, constantly. And if they stop wanting to talk to you, this is the best smell you'll get that you're getting further away from anything helpful. But how you talk to them is really important, too. Doing "the waiter thing" by asking "what would madame like today?" is such a dumb question that there's a whole chunk in the next article about it, plus a nice big chunk of the third one covers what to ask instead.

But even when you ask the right question (if you didn't skip ahead - it's "what did you do?" not "what do you want" - but there's much more discussion of this later on), chances are you'll misinterpet the answer, or the customers won't answer it correctly, or they'll think of an even better answer when they sit bolt upright in bed at 4 o'clock the next morning. So get your response back in quick (i.e.: the changes you've made to their solution in the couple of days since they told you, and deployed somewhere they can see it).

Everything about small-a-agility is hard, but maintaining customer engagement with your work is the hardest of the lot. The good news is, that if you *can* maintain it, you'll end up with a product that actually gets used, and maybe even loved, by people. Though they won't *thank* you for it, obviously.

## Has Agile *ever* been "done right"?

### You have to do **ALL** the things

### But they *seem* contradictory?

### In fact they are checks and balances to each other

The Twelve Angry Snakes

### There are two fundamentals

Deliver value *constantly*.

Get better at doing it (also *constantly")

## WTF is "value" exactly?

Brace yourselves as I'm probably going to bang on about my PhD in this bit...

### Bad news - value is subjective

### Good news - it *can* be measured (at least roughly)

Increased profit, reduced costs, reduced risks.
